Relatório de Arquitetura de Sistemas de Alta Performance para Plataforma de Eventos (MVP)1. Introdução e Visão Estratégica da ArquiteturaO desenvolvimento de plataformas digitais modernas, especificamente no setor de gestão de eventos e bilhetagem (ticketing), exige uma abordagem arquitetural que transcenda a simples implementação de funcionalidades básicas. O cenário atual demanda sistemas capazes de suportar picos de tráfego intensos — característicos de aberturas de vendas de ingressos para grandes eventos —, garantir a integridade transacional financeira em conformidade com regulações bancárias complexas e oferecer uma experiência de usuário fluida e reativa. Este relatório técnico detalha a especificação arquitetural para o Produto Mínimo Viável (MVP) de uma Plataforma de Eventos, fundamentada em uma análise exaustiva das tecnologias NestJS, Prisma, PostgreSQL, React Router v7, Zustand e da API de pagamentos Pagar.me V5.A escolha de um stack tecnológico não é meramente uma seleção de ferramentas, mas uma definição de capacidades operacionais. A arquitetura proposta adota um modelo de Monólito Modular, privilegiando a coesão de código e a simplicidade operacional inicial em detrimento da complexidade distribuída de microsserviços, sem, contudo, sacrificar a escalabilidade futura. A utilização do NestJS como framework de backend permite uma estruturação rigorosa baseada em injeção de dependências e módulos, facilitando a manutenção e a testabilidade. A decisão de implementar uma API Híbrida (GraphQL + REST) responde à necessidade dual do sistema: oferecer flexibilidade de consulta de dados complexos para o frontend (GraphQL) e garantir interoperabilidade padrão com webhooks de gateways de pagamento e serviços de terceiros (REST).No nível de persistência de dados, a adoção do PostgreSQL em conjunto com o Prisma ORM é estratégica. O sistema de eventos requer, paradoxalmente, rigidez relacional para transações financeiras (pedidos, pagamentos, recebedores) e extrema flexibilidade para a definição de conteúdos de eventos (agendas, palestrantes, configurações de ingressos). A utilização de colunas JSONB com índices GIN (Generalized Inverted Index) permite que o PostgreSQL atue com a versatilidade de um banco NoSQL para dados de conteúdo, mantendo as garantias ACID (Atomicidade, Consistência, Isolamento e Durabilidade) para os dados críticos.Para o frontend, a arquitetura reativa baseada em React Router v7 e Zustand endereça o desafio de gerenciar fluxos de usuário complexos, como o "Wizard" de criação de eventos. A capacidade do React Router v7 de gerenciar o carregamento de dados (loaders) e mutações (actions) ao nível da rota, combinada com a gestão de estado global leve e persistente do Zustand, elimina a necessidade de bibliotecas de gerenciamento de estado excessivamente verbosas como Redux, otimizando o tamanho do bundle e a performance de renderização.Finalmente, o núcleo financeiro da plataforma é desenhado em torno da API Pagar.me V5, explorando profundamente suas capacidades de Split de Pagamentos. A arquitetura financeira deve gerenciar a complexidade de dividir valores entre a plataforma (take rate) e os organizadores em tempo real, lidando com arredondamentos, responsabilidades de chargeback (liable flags) e taxas de processamento (MDR) de forma transparente e auditável.2. Fundamentação do Stack Tecnológico e Padrões de DesignA seleção das tecnologias para este MVP foi guiada por critérios de robustez, tipagem estática (type safety), comunidade ativa e suporte a padrões de design corporativos. A tabela abaixo resume as escolhas tecnológicas e suas justificativas arquiteturais primárias.Tabela 1: Matriz de Decisão TecnológicaComponenteTecnologia EscolhidaJustificativa Arquitetural e TécnicaBackend FrameworkNestJS (Node.js)Oferece uma estrutura opinativa inspirada em Angular/Spring, forçando a modularização. Suporte nativo a arquiteturas híbridas (REST/GraphQL) e injeção de dependências robusta, essencial para testabilidade unitária e de integração.LinguagemTypeScriptGarante segurança de tipos em todo o stack (Full Stack Type Safety), reduzindo erros de runtime e melhorando a experiência de desenvolvimento (DX) através de autocompletar e refatoração segura.API ParadigmHíbrido (GraphQL + REST)GraphQL resolve o problema de over-fetching e under-fetching no consumo de dados de eventos complexos pelo frontend. REST é mantido estritamente para endpoints de Webhook (callbacks da Pagar.me) e Health Checks, onde o protocolo HTTP padrão é mandatório.Banco de DadosPostgreSQLSGBD relacional mais avançado do mercado, escolhido especificamente pelo suporte superior a JSONB, permitindo modelagem híbrida (Relacional + Documento) sem a necessidade de um MongoDB paralelo.ORMPrismaAbstração de banco de dados moderna que gera tipos TypeScript automaticamente a partir do schema. Facilita migrações e consultas complexas, embora exija cuidado com performance em queries aninhadas profundas.Frontend RoutingReact Router v7Introduz o conceito de "Data Router", movendo a lógica de fetching para fora dos componentes (loaders), permitindo renderização paralela e eliminando cascatas de requisições (waterfalls).State ManagementZustandBiblioteca minimalista baseada em hooks, ideal para gerenciar estados efêmeros complexos (como formulários multi-etapas) sem o boilerplate do Redux ou Context API.Gateway PagamentoPagar.me V5API robusta focada no mercado brasileiro, com suporte nativo a Split de Pagamentos complexos, Pix, Boleto e Cartão de Crédito, essencial para o modelo de negócios de marketplace.2.1. Arquitetura Híbrida no NestJS: A Convergência NecessáriaA decisão de operar em modo híbrido no NestJS não é trivial e requer uma compreensão profunda do ciclo de vida da requisição. Em um cenário puramente GraphQL, todas as requisições passam por um único endpoint (geralmente /graphql). No entanto, integrações com sistemas legados ou webhooks de terceiros — como a Pagar.me, que envia notificações de status de transação via POST — exigem endpoints REST tradicionais.O NestJS permite que múltiplos contextos de aplicação coexistam. A arquitetura proposta instancia o servidor GraphQL como o manipulador primário de tráfego de clientes (Web/Mobile), enquanto controladores REST são montados em rotas específicas (/api/webhooks/*). Isso permite que o sistema aproveite os Interceptors, Guards e Pipes do NestJS de forma compartilhada ou isolada. Por exemplo, um AuthGuard baseado em JWT pode proteger tanto os Resolvers do GraphQL quanto rotas REST administrativas, enquanto um SignatureGuard específico protege apenas a rota do webhook da Pagar.me, validando a assinatura criptográfica do payload.2.2. PostgreSQL como Plataforma de Dados HíbridaA modelagem de dados para eventos sofre historicamente do problema de rigidez de esquema. Um evento do tipo "Show de Rock" tem atributos completamente diferentes de um "Workshop de Culinária". A abordagem tradicional de EAV (Entity-Attribute-Value) ou tabelas de herança complexas degradam a performance. A arquitetura utiliza o tipo de dado JSONB do PostgreSQL para armazenar os detalhes variáveis do evento. Ao contrário de um campo de texto simples contendo JSON, o JSONB é armazenado em formato binário decomposto, o que permite indexação e consulta eficiente.A utilização de índices GIN (Generalized Inverted Index) é mandatória para garantir a performance dessas consultas. Um índice GIN mapeia chaves e valores dentro do documento JSONB para as linhas da tabela, permitindo buscas como "Encontrar todos os eventos que possuem a tag 'tecnologia'" em tempo logarítmico, ao invés de uma varredura linear na tabela (Full Table Scan). A pesquisa indica que o operador de contenção (@>) é o mais beneficiado por índices GIN com a classe de operador padrão jsonb_ops, sendo ideal para filtros de catálogos de eventos.3. Modelagem de Dados e Esquema de PersistênciaA integridade do sistema depende de um esquema de banco de dados que imponha regras de negócio fundamentais ao nível da persistência, enquanto oferece flexibilidade onde necessário. O Prisma Schema serve como a fonte da verdade para essa estrutura.3.1. Entidades de Identidade e OrganizaçãoA separação entre a autenticação do usuário e seu perfil de organizador é crucial para permitir que um mesmo usuário atue como comprador em um contexto e organizador em outro.User: Entidade raiz de identidade. Armazena credenciais (hash de senha), e-mail, telefone e status de verificação.OrganizerProfile: Extensão do usuário contendo dados públicos da organização (logo, descrição, links sociais).PaymentRecipient: Esta entidade é o elo crítico com o mundo financeiro. Ela armazena o recipient_id da Pagar.me (re_...) e o status da conta bancária vinculada. A integridade desta tabela é vital: sem um registro válido aqui, um organizador não pode publicar eventos pagos. A tabela deve conter campos para auditoria da criação do recebedor, como gatewayStatus e lastSyncedAt.3.2. O Modelo de Eventos e a Estratégia JSONBA tabela Event é o coração do catálogo. Para evitar migrações de banco de dados constantes a cada nova funcionalidade de frontend (ex: adicionar "cor de fundo" à página do evento), utiliza-se um campo JSONB robusto.Estrutura da Tabela Event:id (UUID): Identificador único.slug (String, Unique, Indexed): Para URLs amigáveis (SEO).organizerId (FK): Vínculo com o organizador.status: Enum (DRAFT, PUBLISHED, CANCELLED, SUSPENDED).details (JSONB): Armazena a complexidade variável.Estrutura Interna do Campo details (JSONB):JSON{
  "description": "HTML ou Rich Text",
  "agenda": [
    { "time": "10:00", "title": "Abertura", "speaker": "Nome" }
  ],
  "faq":,
  "settings": {
    "showRemainingTickets": true,
    "primaryColor": "#FF5733",
    "categories":
  },
  "assets": {
    "bannerUrl": "https://...",
    "gallery": ["url1", "url2"]
  }
}
A estratégia de indexação GIN deve ser aplicada sobre este campo. No Prisma, isso é definido através da anotação @@index([details], type: Gin). Isso permite que o backend execute queries complexas de filtro diretamente no banco, como filtrar eventos por categoria ou presença de palavras-chave na agenda, sem carregar todos os registros para a memória da aplicação.3.3. Entidades Financeiras: Pedidos, Transações e ImutabilidadeDiferente dos eventos, os dados financeiros devem ser rígidos e imutáveis. Uma vez que um pedido é criado, seus valores não podem ser alterados retroativamente por mudanças no preço do ingresso.Order: Representa a intenção de compra. Contém o userId (comprador), totalAmount (em centavos), e o status (PENDING, PAID, FAILED, CANCELED).OrderItem: Detalha os ingressos dentro do pedido. Copia o unitPrice da tabela TicketType no momento da compra (snapshot de preço). Inclui também um campo answers (JSONB) para armazenar respostas a formulários personalizados de inscrição (ex: tamanho de camiseta, restrições alimentares).Transaction: Registra a tentativa de pagamento no gateway. Um pedido pode ter múltiplas transações (ex: primeira falhou por saldo insuficiente, segunda aprovada). Campos críticos: gatewayId (tid), paymentMethod, installments, e gatewayMetadata (JSONB para armazenar a resposta bruta da Pagar.me para auditoria).SplitRuleLog: Tabela essencial para auditoria de marketplace. Registra exatamente como o dinheiro foi dividido naquela transação específica. Contém recipientId, amount, percentage, liable, e chargeProcessingFee. Isso protege a plataforma contra disputas futuras, provando quais eram as regras vigentes no momento da transação.4. Integração Financeira Avançada: Pagar.me V5 e Regras de SplitA implementação do Split de Pagamentos na API V5 da Pagar.me é o componente de maior risco e complexidade do sistema. Diferente de um e-commerce tradicional onde 100% do valor vai para o lojista, o modelo de marketplace exige a divisão precisa dos fundos no momento da captura da transação.4.1. Onboarding de Recebedores (KYC Simplificado)Antes de um organizador vender o primeiro ingresso, ele deve ser registrado como um Recipient na Pagar.me. O fluxo de dados envolve a coleta de informações sensíveis (Dados Bancários, CPF/CNPJ). Por questões de segurança e compliance (PCI-DSS, LGPD), recomenda-se que esses dados transitem de forma efêmera pelo backend ou sejam tokenizados diretamente no frontend, embora a criação de recebedores geralmente exija uma chamada server-to-server autenticada com a API Key da plataforma.A criação do recebedor via endpoint POST /core/v5/recipients retorna um ID (re_...). Este ID é a única informação que deve ser persistida permanentemente no banco de dados da aplicação para fins de roteamento de pagamentos futuros. As configurações de transferência (transfer_settings) devem ser definidas no momento da criação: periodicidade de repasse (diário, semanal) e se a antecipação automática está habilitada (geralmente desabilitada para evitar custos financeiros não solicitados).4.2. Matemática e Lógica de SplitA definição do objeto split dentro da transação V5 exige precisão matemática. A API aceita valores em porcentagem (percentage) ou montante fixo em centavos (amount). A prática recomendada para evitar erros de arredondamento em linguagens de ponto flutuante é realizar todos os cálculos em centavos (inteiros) no backend e enviar o split definido por amount.Cenário de Exemplo:Ingresso: R$ 100,00 (10000 centavos).Taxa da Plataforma: 10% + R$ 1,00.Comissão: (10000 * 0.10) + 100 = 1100 centavos.Valor do Organizador: 10000 - 1100 = 8900 centavos.A estrutura do payload JSON para a Pagar.me deve refletir explicitamente quem paga as taxas da transação (MDR - Merchant Discount Rate) e quem é responsável pelo risco (Chargeback).Tabela 2: Configuração de Regras de Split (Payload Pagar.me V5)ParâmetroRegra da PlataformaRegra do OrganizadorSignificado e Impactorecipient_idre_plataformare_organizadorID do recebedor criado previamente na Pagar.me.amount11008900Valor em centavos. A soma deve ser exatamente igual ao total da transação.liabletruetrueDefine quem assume o prejuízo em caso de Chargeback. Se ambos forem true, a dívida é solidária ou dividida proporcionalmente dependendo da configuração da conta mestre.charge_processing_feefalsetrueDefine quem paga a taxa do cartão (ex: 3%). Se true para o organizador, ele recebe os 8900 centavos menos a taxa MDR. A plataforma recebe seus 1100 líquidos.charge_remainderfalsetrue(Conceito lógico da V5) Em caso de divisão percentual inexata, define quem recebe/paga a diferença de centavos.Esta configuração garante que a plataforma proteja sua receita (recebimento líquido) enquanto transfere os custos operacionais do pagamento para o organizador, que é o padrão de mercado.4.3. Idempotência e Tratamento de FalhasTransações financeiras exigem idempotência. Se o servidor cair logo após enviar a requisição para a Pagar.me mas antes de receber a resposta, o sistema pode tentar reenviar a cobrança. Sem uma chave de idempotência, o cliente seria cobrado duas vezes. O cabeçalho Idempotency-Key deve ser preenchido com um UUID único gerado para aquela tentativa de pagamento (geralmente derivado do ID do Pedido + contador de tentativas). A Pagar.me reconhece a chave e retorna a mesma resposta da primeira tentativa sem processar uma nova cobrança.5. Arquitetura de Backend: NestJS, Módulos e WebhooksA organização do código backend deve refletir os domínios de negócio. O uso de módulos do NestJS facilita o encapsulamento.5.1. Estrutura Modular PropostaCoreModule: Configurações globais, conexão com banco de dados (PrismaService), loggers e filtros de exceção globais.AuthModule: Implementa a estratégia JWT. Gerencia login, refresh tokens e guards de proteção de rotas (RBAC - Role Based Access Control).EventsModule: Responsável pelo CRUD de eventos. Contém os Resolvers GraphQL para consulta pública de eventos e mutações protegidas para organizadores. Integra-se com o Prisma para consultas JSONB otimizadas.CheckoutModule: Gerencia o carrinho de compras, reserva temporária de ingressos (usando transações de banco de dados ou Redis para lock otimista) e criação de pedidos.PaymentModule: Encapsula a lógica de integração com a Pagar.me. Não expõe resolvers públicos, mas fornece serviços para o CheckoutModule.WebhookModule: Módulo puramente REST. Expõe controladores (@Controller('webhooks')) para receber POSTs da Pagar.me.5.2. Webhooks e Processamento AssíncronoO processamento de webhooks é crítico para a confirmação de pagamentos. A Pagar.me envia notificações para eventos como transaction.paid, transaction.refused, etc.Fluxo de Processamento Seguro de Webhook:Recepção: O endpoint REST recebe o POST.Validação de Assinatura: Um Guard específico (PagarmeSignatureGuard) intercepta a requisição. Ele calcula o HMAC-SHA256 do corpo da requisição usando a chave secreta da Pagar.me e compara com o cabeçalho X-Pagarme-Signature. Se divergir, rejeita imediatamente (403 Forbidden).Acknowledge Rápido: O controlador retorna 200 OK imediatamente para evitar que a Pagar.me considere timeout e reenvie a notificação.Enfileiramento: O payload validado é colocado em uma fila de mensagens (BullMQ/Redis) para processamento assíncrono.Processamento (Worker): O worker consome a mensagem, busca a transação correspondente no banco de dados pelo gatewayId e atualiza o status do Pedido (Order) e da Transação. Se o status for paid, dispara a emissão dos ingressos e envio de e-mail.6. Arquitetura de Frontend: React Router v7 e Gestão de EstadoO frontend moderno exige uma gestão de estado que suporte a complexidade de fluxos de navegação não lineares e persistência de dados.6.1. O Padrão Wizard com Persistência (Zustand)A criação de um evento é um processo multi-etapas: (1) Informações Básicas -> (2) Detalhes e Agenda -> (3) Ingressos -> (4) Revisão. O usuário pode recarregar a página a qualquer momento e não deve perder os dados preenchidos.O Zustand é escolhido por sua simplicidade e suporte nativo a middlewares. O middleware persist sincroniza automaticamente parte da store com o localStorage.TypeScript// Conceito da Store do Wizard
interface WizardStore {
  step: number;
  eventDraft: Partial<Event>;
  setDraftData: (data: Partial<Event>) => void;
  nextStep: () => void;
}

export const useWizardStore = create<WizardStore>()(
  persist(
    (set) => ({
      step: 1,
      eventDraft: {},
      setDraftData: (data) => set((state) => ({ eventDraft: {...state.eventDraft,...data } })),
      //...
    }),
    { name: 'event-wizard-storage' } // Chave no localStorage
  )
);
Isso garante que o estado sobreviva a "refreshes" do navegador, uma exigência crítica de UX para formulários longos.6.2. Data Loaders e Actions no React Router v7A versão 7 do React Router elimina a necessidade de useEffect para busca de dados inicial. Cada rota define um loader que é executado em paralelo antes do componente renderizar.Loader Paralelo: Para o Dashboard do Organizador, o loader pode disparar promessas simultâneas para buscar o perfil do usuário, estatísticas de vendas e lista de eventos. O React Router aguarda a resolução (ou usa Suspense) para renderizar a página com todos os dados prontos, evitando o efeito de "pipocar" (layout shift) comum em SPAs tradicionais.Actions e Validação: As submissões de formulários são tratadas via actions. A integração com Zod permite validar os dados da requisição (FormData) no cliente antes mesmo de tentar enviar ao backend, ou processar erros de validação retornados pelo servidor (400 Bad Request) e mapeá-los diretamente para os campos do formulário usando bibliotecas como remix-hook-form ou adaptadores manuais.7. Segurança e InfraestruturaA segurança deve ser implementada em camadas (Defense in Depth).Autenticação JWT: Tokens de acesso de curta duração (15 min) e Refresh Tokens de longa duração (7 dias) com rotação (Refresh Token Rotation) para mitigar roubo de tokens.Validação de Inputs: Utilização massiva de Zod no backend (via ZodValidationPipe no NestJS) para garantir que nenhum dado malformado atinja a camada de serviço ou persistência.Sanitização de HTML: Como o campo description do evento pode conter Rich Text (HTML), é obrigatório o uso de bibliotecas de sanitização no backend antes de salvar no JSONB, prevenindo ataques XSS armazenados.Rate Limiting: Proteção de rotas públicas (login, lista de eventos) contra força bruta e DDoS, utilizando ThrottlerModule do NestJS com armazenamento em Redis.8. Especificação Funcional dos CRUDs CríticosPara guiar o desenvolvimento, detalhamos os comportamentos esperados das operações principais.8.1. Create Event (Wizard)Input: Objeto complexo contendo título, slug, datas e o objeto details (JSON) com agenda e assets.Validação: Data de início deve ser anterior à data de fim. Slug deve ser único (verificação assíncrona). URL de assets devem ser válidas.Processamento: Sanitização do HTML da descrição. Criação do registro no banco com status DRAFT.Output: ID do evento criado e objeto completo.8.2. Purchase Ticket (Checkout)Input: ticketTypeId, quantity, cardToken, respostas do formulário customizado.Verificação: Checar disponibilidade de estoque (TicketType.available).Reserva: Decrementar estoque atomicamente (Atomic Increment/Decrement do Prisma ou transação interativa).Cálculo: Calcular total e estrutura de Split (Plataforma vs Organizador).Gateway: Enviar transação para Pagar.me.Persistência: Salvar Order e Transaction com gatewayId e snapshot do split.Rollback: Se o gateway recusar, incrementar o estoque de volta imediatamente.8.3. List Events (Busca)Input: Filtros de data, categoria, texto livre.Query: Utilizar Prisma findMany. Para filtros dentro do JSONB (ex: categoria), utilizar sintaxe de filtro raw ou extensões do Prisma se disponíveis, aproveitando o índice GIN (details @> '{"category": "Music"}').Paginação: Cursor-based pagination para performance em listas infinitas.9. Prompt Refinado e Técnico para DesenvolvimentoCom base em toda a análise arquitetural, técnica e de negócios apresentada, elabora-se a seguir o prompt definitivo. Este prompt é projetado para ser inserido em uma ferramenta de IA generativa de codificação (como GitHub Copilot, Cursor ou ChatGPT Code Interpreter) para gerar o esqueleto (scaffolding) preciso do projeto.PROMPT MESTRE PARA GERAÇÃO DO MVP (Plataforma de Eventos)Função: Atue como um Arquiteto de Software Especialista (Staff Engineer) focado em TypeScript, Node.js e Fintechs.Objetivo: Gerar a estrutura de código, esquemas de banco de dados e lógica de negócios fundamental para o MVP de uma Plataforma de Eventos com Split de Pagamentos.Stack Tecnológico Obrigatório:Backend: NestJS (Node.js) com TypeScript.API Paradigm: Híbrida -> GraphQL (Mercurius/Apollo) para operações do cliente + REST (Controllers) estritamente para Webhooks.Banco de Dados: PostgreSQL.ORM: Prisma (Uso mandatório de tipos Json e índices @@index(..., type: Gin)).Gateway de Pagamento: Pagar.me V5 (Foco absoluto na estrutura de split_rules aninhada em payments).Frontend State/Routing: React Router v7 (Loaders/Actions) e Zustand (com middleware persist).Tarefas de Execução (Output Requerido):1. Definição do Esquema de Banco de Dados (Prisma)Escreva o arquivo schema.prisma completo contendo:Models: User, OrganizerProfile, PaymentRecipient (com recipientId externo), Event, TicketType, Order, Transaction.JSONB & Índices: O modelo Event deve ter um campo details Json para armazenar agenda, FAQ e assets. Adicione o bloco de configuração para habilitar índices GIN neste campo (@@index([details], type: Gin)).Rastreabilidade: O modelo Transaction deve ter um campo splitSnapshot Json para auditar as regras aplicadas no momento da compra.Relacionamentos: Defina as chaves estrangeiras e relacionamentos (1:1, 1:N) corretamente.2. Implementação do Módulo de Pagamento (NestJS)Crie um PagarmeService e os DTOs necessários que implementem a seguinte lógica de negócio crítica:Cálculo de Split: Um método privado que recebe totalAmount (int) e calcula:Fee Plataforma: (Valor * X%) + Taxa Fixa. Configurado com liable: true, charge_processing_fee: false.Fee Organizador: Restante do valor. Configurado com liable: true, charge_processing_fee: true (Organizador paga o MDR).Payload Builder: Construa o objeto JSON exato conforme a documentação da Pagar.me V5, inserindo o array split dentro do nó payments.Idempotência: Garanta que toda chamada de criação de transação aceite e envie um cabeçalho Idempotency-Key.3. Webhook Controller (REST)Implemente um WebhooksController em NestJS:Endpoint: POST /api/webhooks/pagarme.Segurança: Crie um Guard (PagarmeSignatureGuard) que valide o header X-Pagarme-Signature usando HMAC-SHA256 antes de permitir o processamento.Fluxo: O controller deve retornar 200 OK imediatamente e despachar o payload para processamento assíncrono (simule uma chamada de Queue/Service).4. Frontend Store e Lógica de Wizard (Zustand + React Router)Forneça o código TypeScript para:Zustand Store: Uma useWizardStore que armazene o rascunho do evento (Partial<Event>) e o passo atual (step), utilizando o middleware persist para salvar no localStorage.React Router Loader: Um exemplo de função loader para a rota /event/:id/edit que carrega os dados do evento e hidrata a store do Zustand, protegendo a rota para garantir que apenas o dono do evento possa acessá-la.Regras de Qualidade de Código:Use DTOs com class-validator e zod para validação rigorosa.Tipagem forte em tudo (evite any).Inclua comentários explicativos ("Why") sobre as decisões de usar JSONB para detalhes do evento e a lógica de charge_processing_fee.Este relatório e o prompt resultante consolidam todas as informações necessárias para iniciar o desenvolvimento com segurança técnica e alinhamento estratégico, mitigando riscos financeiros e de escalabilidade desde a primeira linha de código.